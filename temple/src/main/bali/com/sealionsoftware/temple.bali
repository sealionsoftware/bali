import bali.Executable
import bali.Boolean
import bali.String
import bali.Exception
import bali.Count
import bali.Counter
import bali.Integer
import bali.RuntimeException
import bali.Serializer
import bali.collection.Map
import bali.collection.Entry
import bali.collection.Collection
import bali.collection.HashMap
import bali.net.Socket
import bali.net.IPAddress
import bali.net.ServerSocket
import bali.net.SocketMonitor
import bali.file.File
import bali.monitor.ConnectionMonitor
import bali.server.HttpHandler
import bali.server.HttpResponse
import bali.server.HttpRequest

import com.sealionsoftware.storage.BeanStore
import com.sealionsoftware.storage.FileBeanStore

constant String@ CONFIG_FILE_NAME = "temple.config"

interface ProtocolHandler {
	declare handle(Socket connection)
}

object StubRouter implements HttpHandler {

	method HttpResponse handle(HttpRequest request){
		return new HttpResponse(
			status: 404,
			headers: new HashMap()
		);
	}
}

object HttpProtocolHandler(HttpHandler router) implements ProtocolHandler {

	method handle(Socket connection){

		CONSOLE << "Receiving Request";

		String? requestLine = << connection;
		if (?requestLine){

			Collection[String] requestLineElements = requestLine / " ";
			if (requestLineElements.size() != 3){
				throw new RuntimeException("The http request line was invalid as it had " + NUMBER_FACTORY.format(requestLineElements.size()) + " elements");
			}

			HttpRequest request = new HttpRequest(
				httpMethod: requestLineElements#1,
				path: requestLineElements#2,
				headers: new HashMap()
			);

			for (String header : connection){
				if (header.size() > 0){
					break;
				}
                Collection[String] headerElements = header / ": ";
                Integer headerElementSize = headerElements.size();
                if (headerElementSize != 2){
                    throw new RuntimeException("The http header is invalid as it had $headerElementSize elements");
                }
                request.headers.put(headerElements#1, headerElements#2);
			}

	        HttpResponse response = router.handle(request);
	        connection << "HTTP/1.1 " + NUMBER_FACTORY.format(response.status) + " OK";

	        for (Entry[String, String] entry : response.headers){
	            connection << entry.key + ": " + entry.value;
	        }

	        connection << "";
	        String? body = response.body;
	        if (?body){
	            connection << body;
	        }

	        CONSOLE << "Response Completed";
        }
	}

}

object TempleServer implements Executable {

	field BeanStore[ServerConfiguration] configStore

	method execute {

		CONSOLE << "Starting Temple";

		File? configFile = FILE_MANAGER.getFile(CONFIG_FILE_NAME);
		if (?configFile){
			configStore = new FileBeanStore(configFile, new ConfigSerializer());
		} else {
			throw new RuntimeException("Could not find config file");
		}

		ServerConfiguration configuration = configStore.load();

		ServerSocket port = NETWORK_MANAGER.openPort(8080);
		ConnectionMonitor[Socket]@ monitor = new SocketMonitor(port);

		while (true){

			monitor.waitForConnection();

			run {

				Socket connection = monitor.getConnection();
				ProtocolHandler handler = new HttpProtocolHandler(new StubRouter());

				try {
					handler.handle(connection);
				} catch (Exception e){
					CONSOLE << "Error Processing Request: " + e.getMessage();
				}
				connection.close();
			}
		}

		port.close();
		CONSOLE << "Temple Exiting";
	}
}

object ConfigSerializer implements Serializer[ServerConfiguration] {

	method String format(ServerConfiguration configuration){
		return "TEST";
	}

	method ServerConfiguration parse(String configuration){
    	return new ServerConfiguration(
    	    webApplications: new HashMap(),
    	    bindings: new HashMap(),
    	    resources: new HashMap()
    	);
    }

}

bean ServerConfiguration {

	property Map[String, WebAppConfiguration] webApplications
	property Map[IPAddress, Map[Integer, String]] bindings
	property Map[String, ResourceConfiguration] resources

}

bean WebAppConfiguration {

	property String groupId
	property String artifactId
	property String versionId

	property Map[String, String] parameters
	property Map[String, String] resources

}

bean ResourceConfiguration {

	property String groupId
	property String artifactId
	property String versionId

	property Map[String, String] parameters
	property Map[String, String] resources

}
